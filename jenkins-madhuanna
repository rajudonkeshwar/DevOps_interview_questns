1) What is a Jenkins pipeline?
Ans: It is pack of plugins and intigarions of tools such as git, maven, sonar, docker, k8s  
that supports integrating and implementing continuous delivery pipelines using code.

2) What is the difference between freestyle project and pipeline?
Ans: Freestyle: UI-based and limited customization. Pipeline: Scripted and supports complex workflows as code.

1. Freestyle Project
A Freestyle Project in Jenkins is a simple, GUI-based job where you configure everything using forms and dropdowns.
üîπ Key Points:
Created using UI ‚Äî no code needed.
You define steps like: source code checkout, build commands, test execution, and deployment manually in the Jenkins dashboard.
Easy to set up for simple CI/CD workflows.
Not easily portable or reusable ‚Äî if you want to replicate it, you need to manually recreate or copy the job.
Harder to maintain for large or complex projects.

üí° Example:
A Freestyle project might pull code from GitHub, run a Maven build, and then deploy an artifact to a server ‚Äî all configured through the Jenkins web interface.

2. Pipeline Project
A Pipeline Project uses code (Jenkinsfile) to define the entire CI/CD workflow in a script.
üîπ Key Points:
Pipeline as Code ‚Äî everything (build, test, deploy) is written in a Jenkinsfile.
Stored inside the source code repository, making it version-controlled.
Supports complex workflows like parallel builds, approvals, error handling, and environment variables.
Easier to reuse and maintain, especially for large teams or multiple environments.
Allows Groovy-based scripting for more flexibility and automation.


4) What are the types of pipelines in Jenkins?
  ans: 
  1. Declarative Pipeline
  This is the most commonly used type.
  Uses a simplified and structured syntax (introduced later to make pipelines easier to write).
  Defined inside a pipeline { } block in a Jenkinsfile.
  Easier to read and maintain; best suited for most CI/CD use cases.

  2. Scripted Pipeline
  Uses Groovy scripting syntax (older and more flexible).
  Everything is written in a script { } block.
  Gives more control and logic (like loops, conditions, custom functions), but is more complex.
  Often used when you need advanced logic or dynamic behavior in your pipeline.

  3. Multibranch Pipeline
  Automatically creates and manages pipelines for each branch in your source control repository (e.g., GitHub).
  Each branch can have its own Jenkinsfile, allowing separate build/test configurations.
  Commonly used in Git-based CI/CD where multiple teams work on different branches.

5) what is jenkins pipeline?
ANS: A Jenkinsfile is a text file that defines the CI/CD pipeline as code. 
      It contains all the build, test, and deployment stages and is stored in the source code repository, 
      allowing version control and automation of the entire workflow.


6) Where is Jenkins installed?
Ans: Jenkins is usually installed on a Linux server or as a Docker container. 
      Its main home directory is /var/lib/jenkins, where all configurations, jobs, and plugins are stored.
      The JENKINS_HOME directory stores:

      Job configurations
      Plugins
      Jobs
      Build logs
      Pipeline scripts
      User and system settings


7) How do you configure a job in Jenkins?
Ans:
  A Jenkins job (or project) defines a set of tasks (like build, test, deploy) that Jenkins should execute. 
  You can configure it either through the UI (for Freestyle jobs) or through a Jenkinsfile (for Pipeline jobs).

  To configure a Jenkins job, go to the Jenkins dashboard, click ‚ÄúNew Item,‚Äù choose the job type (Freestyle or Pipeline), 
  connect your source code repository, define build steps and triggers, then save and run the job. For advanced automation, 
   we use a Jenkinsfile to define everything as code.

  By creating a new job, choosing project type (freestyle/pipeline), and setting steps like source control, build steps, post-build actions.




   Login to Jenkins Dashboard
‚Üí Open your Jenkins URL (e.g., http://localhost:8080)
‚Üí Enter your credentials.

Create a New Job
‚Üí Click on ‚ÄúNew Item‚Äù
‚Üí Enter a Job Name
‚Üí Select ‚ÄúFreestyle project‚Äù (or ‚ÄúPipeline‚Äù if you want code-based setup)
‚Üí Click OK

Configure Source Code Management (SCM)
‚Üí Under the Source Code Management section, select Git
‚Üí Enter your repository URL and credentials.

Add Build Triggers (Optional)
‚Üí You can choose how the job should start:

Build periodically (like a cron job)
Poll SCM (automatically build on code changes)
Build after another project

Add Build Steps
‚Üí Under Build, click ‚ÄúAdd build step‚Äù
‚Üí Choose what you want Jenkins to do (e.g., ‚ÄúExecute shell‚Äù, ‚ÄúInvoke Gradle/Maven‚Äù, etc.)
‚Üí Example: mvn clean package

Add Post-Build Actions
‚Üí Configure what should happen after the build, like:

Publish artifacts
Send email notifications
Deploy to server
Save and Build
‚Üí Click Save
‚Üí Hit ‚ÄúBuild Now‚Äù
‚Üí You can check console output for logs and results.


8) What is jenkins executors?
Ans:
  A Jenkins executor is a worker process that runs one build at a time on a Jenkins node. 
  The number of executors determines how many jobs can run in parallel. If all executors are busy, new builds wait in the queue.

  A Jenkins executor is basically a slot or a worker thread on a Jenkins node (master or agent) that runs your jobs.
  Think of it like this:
  Each executor is a seat where Jenkins can run one build at a time.
  If a node has 2 executors, that means it can run 2 jobs in parallel on that machine.


9) How do we trigger jenkins job automatically?
ans:
  1. Poll SCM (Source Code Management)
Jenkins regularly checks the source code repository (e.g., GitHub) for changes.
If it detects any new commits, it automatically triggers the job.

Configuration:
Go to Job ‚Üí Configure ‚Üí Build Triggers ‚Üí Poll SCM
Add a schedule (CRON format), for example:
H/5 * * * * 
‚Üí This checks every 5 minutes.
üí° Note: This doesn‚Äôt trigger instantly; it polls periodically.

2. Webhook (Preferred for GitHub/GitLab)
This is the most efficient and real-time way.
When you push code to GitHub, it sends a webhook to Jenkins to start the job immediately.
Setup:
In Jenkins:
Enable ‚ÄúGitHub hook trigger for GITScm polling‚Äù under Build Triggers.
In GitHub repo:
Go to Settings ‚Üí Webhooks ‚Üí Add Webhook
Add your Jenkins URL:
http://<jenkins-server>:8080/github-webhook/

Choose application/json and select ‚ÄúJust the push event.‚Äù
üí° Use this for real-time CI/CD pipelines.

3. Build Periodically (Cron Job Style)
Used to trigger builds on a fixed schedule, even if no code changes happen.
Example:
H 2 * * *   ‚Üí runs daily at 2 AM
H/10 * * * * ‚Üí runs every 10 minutes
Set this under:
Build Triggers ‚Üí Build periodically

4. Upstream/Downstream Triggers
One Jenkins job automatically triggers another after completion.

Example:
Job A builds the code.
When Job A finishes successfully, it triggers Job B for deployment.
Set under:
Post-build Actions ‚Üí Build other projects

5. Trigger from Pipeline Script
You can define automatic triggers directly in your Jenkinsfile.
Example:
pipeline {
    triggers {
        cron('H/15 * * * *')  // Run every 15 minutes
    }
    stages {
        stage('Build') {
            steps {
                echo "Building..."
            }
        }
    }
}

‚úÖ Short Interview Answer:

We can trigger Jenkins jobs automatically using several methods ‚Äî most commonly by Git webhooks for real-time triggers, 
Poll SCM for periodic checks, Build periodically using cron schedules, or Upstream/Downstream job dependencies. 
In pipelines, triggers can also be defined in the Jenkinsfile.



6) can you explain about upstream, down stream jobs in jenkins?
Ans:
  1. Upstream Job
    An upstream job is the job that triggers another job after it completes.
    Think of it as the source job.
    Example
    Job A builds the code ‚Üí after it succeeds, it triggers Job B for testing.
    Here, Job A is upstream of Job B.

  2. Downstream Job
    A downstream job is the job that gets triggered by another job.
    Think of it as the dependent job.
    Example:
    Job B runs after Job A completes ‚Üí Job B is downstream of Job A.

  3. How to Configure Upstream/Downstream Jobs:
  Using Post-Build Actions in Freestyle Job:
  Go to ***Job A ‚Üí Configure ‚Üí triggers ‚Üí Build after other projects are built ***
  Enter the downstream job name (Job B)
  Optionally choose ‚ÄúTrigger only if build is stable‚Äù

7) Difference between master and agent?
Ans:
1. Jenkins Master
The master is the central server that controls the Jenkins environment.
Responsibilities of Master
Manage Jenkins configuration and system settings.
Schedule jobs and assign them to agents (or run on master itself).
Monitor agents and track job execution status.
Store build history, logs, and artifacts (though agents may also store temporary artifacts).
Provide UI and API access to users.
Note: You can run small jobs on master itself, but heavy builds are usually offloaded to agents.

2. Jenkins Agent (or Slave)
An agent is a worker node that performs the actual job execution.
Responsibilities of Agent:
Executes jobs assigned by the master.
Can run multiple executors to handle parallel builds.
Can be on a different machine (Linux, Windows, Docker container).
Reports build results back to the master.

Jenkins Master is the central server responsible for scheduling jobs, managing configuration, and monitoring agents. 
Agents are worker nodes that execute jobs assigned by the master, often running on separate machines to distribute workloads efficiently.


8) How to secure Jenkins?
Ans: 

üîπ How to Secure Jenkins

Enable Authentication
Require users to log in before accessing Jenkins.
Use Jenkins‚Äô own user database, LDAP, Active Directory, or OAuth/GitHub authentication.
Set Proper Authorization
Control who can do what using Matrix-based security or Project-based Matrix Authorization.
Avoid giving everyone admin privileges; assign roles like Admin, Developer, or Viewer.

Use HTTPS
Enable SSL/TLS to encrypt traffic between users and Jenkins.
Can be done via reverse proxy (Nginx/Apache) or Jenkins native SSL support.
Secure Jenkins Master and Agents
Restrict network access to the Jenkins master and agents.

Only allow trusted hosts and users.
Use firewall rules or VPN.

Secure Credentials
Store passwords, tokens, and keys in Jenkins Credentials Plugin instead of hardcoding in jobs or Jenkinsfile.
Use secret text, secret files, or SSH keys.
Keep Jenkins and Plugins Updated
Regularly update Jenkins core and installed plugins to patch known vulnerabilities.
Avoid using unverified or deprecated plugins.


To secure Jenkins, we enable authentication and authorization, use HTTPS url, restrict access to the master and agents, 
store credentials securely, keep Jenkins and plugins updated, enable CSRF protection, and audit user actions. 
This ensures only authorized users can access and execute jobs safely.
